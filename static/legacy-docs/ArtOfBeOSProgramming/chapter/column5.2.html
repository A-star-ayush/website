
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html lang="Ja">
<head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
	<title>Art of BeOS Programming</title>
	<link href="../css/format.css" rel="stylesheet" type="text/css">
	<link href="../css/layout.css" rel="stylesheet" type="text/css">
</head>

<body>

<div id="pagewidth">

<div id="main">
<span id="column_t">囲みコラム</span>
<h1>マルチスレッド処理と共有データのロック</h1>
<br/>
ウィンドウにロックをかけるというのは、他のスレッドがウィンドウにアクセスできないようにすることです。BeOSのアプリケーションではマルチスレッド動作が基本ですから、複数のスレッドが一つのウィンドウにアクセスして描画処理を行うことが可能です。とはいえ、それぞれのスレッドが一斉に描画処理を行ったのでは、とんでもないことになるでしょう。たとえば、リスト5.6ではビューオブジェクト(viewObj)に対してSetHighColor()メソッドを呼び出して描画に使う前景色をグレーにセットし、その後FillRect()メソッドを呼び出してビュー全体を塗り潰しています。もし、SetHighColor()の呼び出しが終わってFillRect()の呼び出しが始まるまでの間に、他のスレッドが割り込んでビューの前景色を赤にセットしてしまったら、何が起こるか考えてみて下さい。<br/>
<br/>
BeOSでは、それぞれのスレッドの実行はプリエンプティブにスケジューリングされますので、普通にやったのではいつ他のスレッドに割り込まれるか分かりません。これを防ぐために行うのが、ロックです。あるスレッドがウィンドウに対してロックをかけると、そのスレッドがロックを解除するまで、他のスレッドは同じウィンドウに対してロックをかけることができません。ロックをかけようとしても、先にロックしたウィンドウが解除を行うまで待たされます。これについては第3章の「マルチスレッドによる並行処理」という節(3.3)で詳しく説明しましたので、読みとばしてしまって分からない人は、読み直してみて下さい。<br/>
<br/>
BeOSのAPIでは、ビューオブジェクトを利用してウィンドウに描画を行ったり、またウィンドウを隠したり表示したりといった、画面の表示内容に変更を加える処理を行う場合は、必ずウィンドウにロックをかける決まりになっています。章末の練習問題でも取り上げていますが、ロックをかけずにこれらの処理を行おうとしても、API側でチェックしているのでエラーになります。この決まりをアプリケーションに守らせることにより、同じウィンドウにアクセスする二つのスレッドの描画処理が入り交じってしまわないようにしているのです。<br/>
<br/>
つまり、全体をグレーに塗ったはずのビューが赤くなり、そして黒いはずの文字が赤く描かれてしまう、という心配が不要になるというわけです。<br/>
<br/>

<hr>
<address>
Art of BeOS Programming<br/>
koga@stprec.co.jp
</address>


</div><!-- End of main -->

</div><!-- End of pagewidth -->

</body>

</html>

