+++
type = "article"
title = "How to Write a Printer Driver"
date = "2004-02-15T05:00:00.000Z"
tags = ["printing", "driver"]
+++

<div class="field field-type-text field-field-body"><h3 class="field-label">Body</h3><div class="field-items"><div class="field-item"><p>A <em>printer driver</em> in BeOS R5 is an add-on that exports a specific C interface. This add-on is used by the print_server to add a new printer, configure a page, configure the print job, and print the print job on the printer. This article describes how the print_server interfaces with the printer driver.</p>

<p>The print_server is responsible for maintaining common settings. BMessage objects are used to pass settings from the print_server to a printer driver and vice versa. If the printer driver has to return a BMessage object and wants to show the successful completion of an operation, it has to set the field what to the value &#39;okok&#39;. To indicate an error, the preferred method is to return NULL. In some cases the print_server interprets a value in what other than &#39;okok&#39; as the failure of an operation. A printer driver should not rely on this; instead, it should return NULL.</p>

<p>A <em>print job</em> is a file, generated by a printing application using the Interface Kit class BPrintJob (see Figure 1). This file contains archived BPicture objects &#151 one for each call made to BPrintJob::DrawView(). A raster printer driver, for example, can use the BPicture objects for each page and draw them into a BBitmap object and convert the pixels in the BBitmap object into the format the printer understands. The driver can make changes to the content of the BPicture, including dithering and color correction. There is no standard or common code for these features in R5.</p>

<p>When a printer driver is requested to print a print job it uses a <em>transport add-on</em> to transfer data to the printer. Transport add-ons know how to write to an individual device (parallel, USB, network, etc.) Separating transports from drivers allows R5 to work with, for example, a printer on a USB port or the same printer on a parallel port with only one driver. It also makes writing the drivers simpler: the driver outputs a &quot;stream&quot; of data, without having to know how it is delivered.</p>

<img src="/files/beos_r5_printing_overview.png" alt="" />

<p><strong>Figure 1:</strong> BeOS R5 Printing Overview</p>

<h3>Driver Location</h3>

<p>System printer drivers that are installed with the OS are located in B_BEOS_ADDONS_DIRECTORY in the subfolder <em>Print</em> (i.e., <em>/boot/beos/system/add-ons/Print</em>).<br />

Printer drivers installed by the user are usually placed into B_USER_ADDONS_DIRECTORY in the subfolder <em>Print</em> (i.e., <em>/boot/home/config/add-ons/Print</em>).</p>

<p>Transport add-ons (like Print To File, Parallel Port, and USB Port) are located in a folder named <em>transport</em> inside of the system or user printer driver folder.</p>

<h3>The Life of a Printer Driver</h3>

<h4>Installing the Printer Driver</h4>

<p>To install a printer driver, the driver has to be moved into one of the printer driver folders. Printer drivers should not link to shared libraries other than those provided by the OS &#151 third-party libraries should be statically linked instead. This helps to avoid version conflicts.</p>

<h4>Adding a New Printer</h4>

<p>Users add a new printer to the system using the Printers preflet. They select a <em>printer name</em>, <em>printer type</em>, and <em>transport add-on</em>. The preference application creates a <em>spool folder</em> with the name of the printer in B_USER_PRINTERS_DIRECTORY (i.e., <em>/boot/home/config/settings/printers</em>). The name of the transport add-on is stored in the spool folder&#39;s file attribute named transport. The type code of this attribute is B_STRING_TYPE.</p>

<p>The print_server, when notified of the new printer, calls the printer driver to configure the printer. The function prototype within the printer driver for this is:</p>

<pre>char* add_printer(char* printer_name);<br /></pre>

<p>This gives the printer driver the chance to open a window for configuration of the printer model. The configuration can be stored in the attributes of the spool folder. On success the printer driver should return the pointer to the string printer_name or NULL on failure.</p>

<h4>Configuring the Page</h4>

<p>When an application calls BPrintJob::ConfigPage(), the print_server requests that the printer driver configure the page by calling: </p>

<pre>BMessage* config_page(BNode* spool_folder, BMessage* settings);<br /></pre>

<p>The printer server calls this function with spool_folder, a pointer to a BNode object whose path is the spool folder, so the printer driver can access its attributes. It also passes settings, a pointer to a BMessage object that contains the previous page settings, if any. At the very least, the page size and orientation have to be specified.</p>

<p>The printer driver usually opens a window to let the user select the page size, orientation, and (optionally) other settings; these other settings may be printer specific. The mandatory fields are:</p>

<p><table border="1" cellpadding="4" width="500"> <tbody><tr><th>Field</th> <th>Type Code</th> <th>Meaning</th> </tr><tr> <td>printable_rect</td> <td>B_RECT_TYPE</td> <td>The printable rectangle in 1/72 inches. That is the area the printer is able to write into.</td> </tr><tr> <td>paper_rect</td>  <td>B_RECT_TYPE</td> <td>The paper rectangle in 1/72 inches.</td> </tr><tr> <td>orientation</td> <td>B_INT32_TYPE</td> <td>0 ... portrait, 1 ... landscape. </td> </tr><tr> <td>xres</td> <td>B_INT32_TYPE</td> <td>Horizontal DPI.</td>  </tr><tr> <td>yres</td> <td>B_INT32_TYPE</td> <td>Vertical DPI.</td> </tr></tbody></table></p>

<p>If the configuration was successful, a new BMessage object with the settings is returned. If it fails, NULL has to be returned (e.g. in response to the user clicking the Cancel button in the page setup window).</p>

<h4>Configuring the Print Job</h4>

<p>The main purpose of the configuration of the print job is to let the user select the range of pages to be printed and the number of copies of each page that should be printed. Again, printer-driver-specific settings can be added.</p>

<p> The print_server calls this function with the same parameters as it does when configuring the page:</p>

<pre>BMessage* config_job(BNode* spool_folder, BMessage* settings);<br /></pre>

<p>Settings contains the fields from page configuration, which should not be changed. The mandatory fields that have to be added or changed are:</p>

<table border="1" cellpadding="4" width="500"> <tbody><tr><th>Field</th> <th>Type Code</th> <th>Meaning</th> </tr><tr> <td>first_page</td> <td>B_INT32_TYPE</td> <td>The page number of the first page to be printed. Starts with 1.</td>  </tr><tr> <td>last_page</td> <td>B_INT32_TYPE</td> <td>The page number of the last page to be printed. If all pages should be printed its value should be MAX_INT32 (= 0x7fffffffL).</td> </tr><tr> <td>copies</td> <td>B_INT32_TYPE</td> <td>The number of copies.</td>  </tr></tbody></table></p>

<p>On success, a new BMessage object with the settings should be returned; otherwise NULL has to be returned.</p>

<h3>Using a Transport Add-On</h3>

<p>The printer driver has to load the transport add-on associated with the printer. The name of the transport add-on is stored in the file attribute transport of the spool folder. The driver should first look into the user&#39;s printer folder (start at B_USER_ADDONS_DIRECTORY then proceed to <em>Print/transport</em>) to find the named transport add-on there. If it fails, it should look into the system printer folder (start at B_BEOS_ADDONS_DIRECTORY then proceed to <em>Print/transport</em>).</p>

<p>The transport add-on exports two C functions:</p>

<pre>BDataIO* init_transport(BMessage *settings);<br />void     exit_transport(void);<br /></pre>

<p>init_transport() is passed a BMessage object with a field printer_file of type B_STRING_TYPE containing the path to the spool folder. On success it returns a BDataIO object and NULL on failure. The BDataIO object can be used to write data to the printer.</p>

<p>The printer driver must <strong>not</strong> delete the BDataIO object. Instead it has to call exit_transport() and then unload the transport add-on.</p>

<p>Sample code can be found in class PrintTransport&#39;s method Open() in the folder <em><a href="http://svn.berlios.de/viewcvs/haiku/haiku/trunk/src/add-ons/print/shared/">src/add-ons/print/shared</a></em> in the Haiku source code repository. The header file <em>PrintTransport.h</em> can be found in <em><a href="http://svn.berlios.de/viewcvs/haiku/haiku/trunk/headers/private/print/">headers/private/print</a></em>.</p>

<h4>Printing the Print Job</h4>

<p>Now we come to the core of a printer driver. This is the prototype of the function that is called by the print_server when the print job is ready to be processed:</p>

<pre>BMessage* take_job(BFile* print_job, BNode* spool_folder, BMessage* settings);<br /></pre>

<p>The print job can be read using the file print_job. Its file format is explained below. Again the attributes of the spool folder can be accessed using spool_folder and the settings from the page configuration are also available, e.g. to get the page size.</p>

<p> To write data to the printer, the printer driver has to load the transport add-on and create a BDataIO object as explained in the section entitled <em>Using a Transport Add-on</em>.</p>

<p>To read the print job the class PrintJobReader from the Haiku source code repository can be used. This code snippet demonstrates how PrintJobReader can be used:</p>

<pre>PrintJobReader reader(print_job);<br />if (reader.InitCheck() == B_OK) {<br />  // the settings stored in the print job<br />  BMessage* settings = reader.JobSettings();<br />  <br />  // page number of the first page<br />  int32 firstPage = reader.FirstPage();<br />  <br />  // page number of the last page<br />  int32 lastPage = reader.LastPage();<br />  <br />  // paper and printable rectangle<br />  BRect paperRect = reader.PaperRect();<br />  BRect printableRect = reader.PrintableRect();<br />  <br />  // resolution<br />  int32 xdpi, ydpi;<br />  reader.GetResolution(&amp;xdpi, &amp;ydpi);<br />  <br />  int32 pages = reader.NumberOfPages();<br />  // for each page<br />  for (int page = 0; page &lt; pages; page ++) {<br />    <br />    PrintJobPage pjp;<br />    <br />    if (reader.GetPage(page, pjp) == B_OK) { <br />      BPicture picture; <br />      BPoint point; <br />      BRect rect;<br />      <br />      // for each picture on page<br />      while (pjp.NextPicture(picture, point, rect) == B_OK) {<br />        // do some thing with the picture at point<br />      }<br />    }<br />  }<br />}<br /></pre>

<p>What the printer driver does with the data from the print job is printer dependent and is not within the scope of this article. Sample source code can be found in the Haiku source code repository. For raster printer drivers see Haiku printer drivers Canon LIPS, PCL5, or PCL6. For &quot;vector&quot; printer drivers see the Haiku PDF printer driver.</p>

<table border="1" width="500"> <tbody><tr><th>Print Job File Format</th>  </tr><tr> <td><pre>struct  print_file_header {<br />  int32  version;<br />  int32  page_count;<br />  off_t  first_page;<br />  int32  _reserved_3_;<br />  int32  _reserved_4_;<br />  int32  _reserved_5_;<br />};<br /></pre></td></tr><tr><td> This is declared in <em>PrintJob.h</em>.  In the print job file, the header is followed by a flattened BMessage object containing the settings that are passed to take_job(). <br /> The print job file contains page_count <em>page sections</em>. The first starts at file offset first_page.</td></tr>  </tbody></table>  <p><table border="1"> <tbody><tr><th>Page Section </th></tr><tr> <td><pre>struct  page_header {<br />  int32   picture_count;<br />  off_t   next_page;<br />  int32   _reserved[10];<br />};<br /></pre></td> </tr><tr> <td> This is followed by picture_count <em>picture sections</em>. <br />  The next page section starts at file offset next_page. </td> </tr></tbody></table>  </p><p><table border="1"> <tbody><tr><th>Picture Section </th></tr><tr> <td><pre>struct _picture_header_ {<br />  BPoint  point;<br />  BRect  rect;<br />};<br /></pre></td> </tr><tr> <td> This is followed by a flattened BPicture object.  </td> </tr></tbody></table></p>

<h4>Removing a Printer</h4>

<p>With the Printers preference application a printer can be removed. This deletes the printer folder from B_USER_PRINTERS_DIRECTORY if no pending print jobs exist.</p>

<h4>Uninstalling a Printer Driver</h4>

<p>A printer driver should be removed only if all printers have been removed with the Printers preflet. To remove the printer driver, the printer driver add-on has to be deleted from the system or user printer driver folder. There is little advantage to doing this &#151 printer drivers are small and do not add to boot time or decrease system performance.</p>

<h4>Updating a Printer Driver</h4>

<p>Usually if a new version of a printer driver should be installed it is not necessary to remove the added printers from the system. In most cases it is sufficient to replace the printer driver add-on.</p>

<h3>Issues to Consider When Writing a (Printer Driver) Add-On</h3>

<p> A printer driver add-on is loaded on demand and usually unloaded as soon as it is not used any more. This means global states cannot be stored in global variables of the printer driver add-on. As mentioned already, the printer driver can store global states in an attribute of the spool folder.</p>

<p> It is also possible that multiple instances of the printer driver add-on are loaded and used at the same time (e.g. when the printer prints a print job and the user configures a page at the same time).</p>

<p> Multiple threads started by the printer driver can also be an issue. The printer driver has to ensure that all threads that have been started inside of the driver have exited before the driver returns from a function. E.g., when the printer driver opens a window for the configuration of a page in config_page(), a separate thread for the window is started. config_page() has to wait until the window is closed and the object that represents the window is completely destroyed, otherwise it could happen that the printer driver unloads the printer driver add-on while the window thread is still running. This will lead to a memory access violation because the window thread still accesses code in the add-on that is not loaded any more.</p>
<br class="clear" /><br class="giImageBlock-clear-both" /></div></div></div>