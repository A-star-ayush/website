+++
type = "article"
title = "I Will Survive"
date = "2002-10-30T11:00:00.000Z"
tags = ["media", "media_server", "restart"]
+++

<div class="field field-type-text field-field-body"><h3 class="field-label">Body</h3><div class="field-items"><div class="field-item"><p>It&#39;s not something that might happen in a rare circumstance, something that can be neglected in the design of your media application, but something that <em>will</em> happen as soon as the user hits that big inviting button on front of the Media preference panel - the media_server quitting while you rely on it and the connections you have established with your own and other media nodes. So, for your programs to survive this situation, is quite desirable. And, of course, Soundplay taught us first - it can be done!</p>

<p>The first step towards that goal is detecting a media_server restart at all. It cannot be done through any of the event listening methods that the BMediaRoster already provides. You have to look elsewhere - another roster perhaps? You register one of your loopers with the application roster to receive notices whenever an application is launched or quit. In the following example, I will use the BApplication object. From there, I will broadcast the event of a media_server restart to all parts of the application using media nodes. The best place to register with the application roster is probably BApplication::ReadyToRun() like this:</p>

<pre>#define MEDIA_SERVER_SIG &quot;application/x-vnd.Be.media-server&quot;<br />#define ADDON_SERVER_SIG &quot;application/x-vnd.Be.addon-host&quot;<br /><br /><br />void<br />ExampleApp::ReadyToRun()<br />{<br />    // Now tell the application roster, that we&#39;re interested<br />    // in getting notifications of apps being launched or quit.<br />    // In this way we are going to detect a media_server restart.<br />    be_roster-&gt;StartWatching(BMessenger(this, this),<br />                             B_REQUEST_LAUNCHED | B_REQUEST_QUIT);<br />    // we will keep track of the status of media_server<br />    // and media_addon_server<br />    fMediaServerRunning =  be_roster-&gt;IsRunning(MEDIA_SERVER_SIG);<br />    fMediaAddOnServerRunning = be_roster-&gt;IsRunning(ADDON_SERVER_SIG);<br />}<br /></pre>

<p>The ExampleApp class has two flags keeping track of the status of both the media_sever and media_addon_server. The reason is simply that these are two seperate applications, but equally vital for the media kit to be valid, and we don&#39;t want to take any actions, before they&#39;re not both running or have both died.</p>

<p>BTW, you might want to unregister with the roster too, most likely in QuitRequested().</p>

<pre> <br />bool<br />ExampleApp::QuitRequested()<br />{<br />    bool quit = false;<br />    // find out if we can quit here<br />    // ...<br />    if (quit)<br />        be_roster-&gt;StopWatching(BMessenger(this, this));<br />    return quit;<br />}<br /></pre>

<p>The messages notifying us of the requested events will appear in our MessageReceived() method. Though we receive messages for every application launching or quitting, we&#39;re only interested in the two servers.</p>

<pre> <br />void<br />ExampleApp::MessageReceived(BMessage* msg)<br />{<br />    switch (msg-&gt;what) {<br />    case B_SOME_APP_LAUNCHED:<br />    case B_SOME_APP_QUIT: {<br />        const char* mimeSig;<br />        if (msg-&gt;FindString(&quot;be:signature&quot;, &amp;mimeSig) == B_OK) {<br /><br />            bool isMediaServer = strcmp(mimeSig, MEDIA_SERVER_SIG) == 0;<br />            bool isAddonServer = strcmp(mimeSig, ADDON_SERVER_SIG) == 0;<br />            if (isMediaServer)<br />                fMediaServerRunning = (msg-&gt;what == B_SOME_APP_LAUNCHED);<br />            if (isAddonServer)<br />                fMediaAddOnServerRunning = (msg-&gt;what == B_SOME_APP_LAUNCHED);<br />            if (isMediaServer || isAddonServer)<br />                if (!fMediaServerRunning &amp;&amp; !fMediaAddOnServerRunning) {<br />                    fprintf(stderr, &quot;media server has quit.<br />&quot;);<br />                    // everybody can start cleaning up their media nodes<br />                    BMessage quitMessage(MSG_MEDIA_SERVER_QUIT);<br />                    BroadcastMessage(&amp;quitMessage);<br />                }<br />                else if (fMediaServerRunning &amp;&amp; fMediaAddOnServerRunning) {<br />                    fprintf(stderr, &quot;media server was launched.<br />&quot;);<br />                    // HACK!<br />                    // quit our now invalid instance of the media roster<br />                    // so that before new nodes are created,<br />                    // we get a new roster<br />                    BMediaRoster* roster = BMediaRoster::CurrentRoster();<br />                    if (roster) {<br />                        roster-&gt;Lock();<br />                        roster-&gt;Quit();<br />                    }<br />                    // give the servers some time to init...<br />                    snooze(3000000);<br />                    // tell everybody to re-init their media nodes<br />                    BMessage launchedMessage(MSG_MEDIA_SERVER_LAUNCHED);<br />                    BroadcastMessage(&amp;launchedMessage);<br />                }<br />        }<br />        break;<br />    }<br />    default:<br />        BApplication::MessageReceived(msg);<br />        break;<br />    }<br />}<br /><br /></pre>

<p>Our sample application has a method BroadcastMessage(), that simply sends a message to all of it&#39;s document windows or something of that kind. We just assume, that your application supports multiple instances of whatever it has for a media node setup. All of those need to be notified in a centralized way, which our application object takes care of.</p>

<p>Alright, this code above has one interesting bit. It quits the media roster instance, of which there is probably one running in your application team if you interacted with the media_server in any way. This object is just your ordinary BLooper. If by design or for other reasons remains pure speculation at this point in time - this object is of no use anymore, toast so to speak, as soon as the media_sever has been restarted. In another words, your previous connection with the server is broken. So you need a new one, which will be created for you the next time you call BMediaRoster::Roster().</p>

<p>The implications are this: what do you do with your invalid nodes and connections? For system nodes, you can&#39;t do anything. They will most likely be gone already. Fortunately, you <em>can</em> get rid of nodes without the roster. BMediaNode::Release() will serve this purpose just fine. However, you should not attempt to break the connection between nodes, that have been connected before the server died. Or you will be in for a nice little meeting with Rheinmachefrau, and that won&#39;t be pretty! Actually, the politically correct name for that thread shoud have been &quot;Reinigungskraft&quot;, but let&#39;s not get into that too far.</p>

<p>All you need in your TearDownNodes() function, is a distinction between a normal clean exit, and the dirty one, that needs to follow a media_server breakdown. In the dirty case, simply ignore existing connections and system nodes, and generally don&#39;t use BMediaRoster functions. The other thing to watch out for is locking. Since our application could be notified of a media_server shutdown when another thread in our team is right in the middle of using the BMediaRoster instance, you need to lock the BMediaRoster when you start using it, and unlock it when you&#39;re done.</p>

<p>An example node cleanup method could thus look like this:</p>

<pre> <br />void<br />ExampleWindow::TearDownNodes(bool disconnect)<br />{<br />    // err needs to default to B_OK, since the Roster call only<br />    // sets it in case of an error<br />    status_t err = B_OK;<br />    BMediaRoster* mediaRoster = BMediaRoster::Roster(&amp;err);<br />    if (err != B_OK) {<br />        fprintf(stderr, &quot;ExampleWindow::TearDownNodes()&quot;<br />                        &quot; - error getting media roster: %s<br />&quot;,<br />                        strerror(err));<br />        mediaRoster = NULL;<br />    }<br />    // begin mucking with the media roster<br />    bool mediaRosterLocked = false;<br />    if (mediaRoster &amp;&amp; mediaRoster-&gt;Lock())<br />        mediaRosterLocked = true;<br /><br />    if (fAudioProducer) {<br />        status_t err;<br />        // Ordinarily we&#39;d stop *all* of the nodes in the chain<br />        // at this point. However, one of the nodes is the System Mixer,<br />        // and stopping the Mixer is a Bad Idea (tm).<br />        // So, we just disconnect from it, and release our references<br />        // to the nodes that we&#39;re using. We *are* supposed to do that,<br />        // even for global nodes like the Mixer.<br />        if (disconnect &amp;&amp; mediaRoster) {<br />            err = mediaRoster-&gt;Disconnect(fAudioConnection.producer.node,<br />                                          fAudioConnection.source,<br />                                          fAudioConnection.consumer.node,<br />                                          fAudioConnection.destination);<br />            if (err != B_OK)<br />                printf(&quot;Error disconnecting audio nodes:&quot;<br />                       &quot;  %ld (%s)<br />&quot;, err, strerror(err));<br />        }<br /><br />        fAudioProducer-&gt;Release();<br />        if (disconnect &amp;&amp; mediaRoster) {<br />            err = mediaRoster-&gt;ReleaseNode(fAudioConnection.consumer);<br />            if (err != B_OK)<br />                printf(&quot;Error releasing audio consumer: %s<br />&quot;,<br />                       strerror(err));<br />        }<br />        fAudioProducer = NULL;<br />        snooze(20000LL);<br />    }<br />    // we&#39;re done mucking with the media roster<br />    if (mediaRosterLocked)<br />        mediaRoster-&gt;Unlock();<br />}<br /><br /><br /></pre>

<p>In the above code, fAudioProducer is our own media node object, and it is connected to the system mixer. The connection details (endpoints and nodes) are stored in a custom connection structure fAudioConnection. Ordinary, TearDownNodes() would be called with disconnect = true. Only in the case of a media server shutdown that flag is false. Additionally, this method does not rely on a valid BMediaRoster instance. But if it&#39;s there, it locks the object, so that nothing else can interfere.</p>  <p>When the object holding the media node setup, in our example a document window, receives the message from the application, that the server has died or started, this is what happens:</p>

<pre> <br />void<br />ExampleWindow::MessageReceived(BMessage* msg)<br />{<br />    switch (msg-&gt;what) {<br />        case MSG_MEDIA_SERVER_QUIT:<br />            if (fNodesRunning)<br />                StopNodes();<br />            TearDownNodes(false);<br />            break;<br />        case MSG_MEDIA_SERVER_LAUNCHED:<br />            SetupNodes();<br />            if (fNodesRunning)<br />                StartNodes();<br />            break;<br />        default:<br />            BWindow::MessageReceived(msg);<br />            break;<br />    }<br />}<br /></pre>

<p>fNodesRunning is not, as you might think, representing the run status of our node setup, but if we have valid nodes at all. According to this flag, you might want to be prepared to give some feedback to the user when something went wrong.</p>   <p>So what&#39;s missing? The rest of the code, of course, so here it is:</p>

<pre> <br />#define ErrorAlert(str, status) \<br />        printf(str &quot; Error: %s<br />&quot;, strerror(status))<br /><br />status_t<br />ExampleWindow::SetupNodes()<br />{<br />    media_raw_audio_format format;<br />    format = media_raw_audio_format::wildcard;<br />    format.frame_rate = 44100.0;<br />    format.channel_count = 2;<br />    format.format = media_raw_audio_format::B_AUDIO_FLOAT;<br /><br />    if (B_HOST_IS_BENDIAN)<br />        format.byte_order = B_MEDIA_BIG_ENDIAN;<br />    else if (B_HOST_IS_LENDIAN)<br />        format.byte_order = B_MEDIA_LITTLE_ENDIAN;<br /><br />    status_t status = B_OK;<br /><br />    // find the media roster<br />    BMediaRoster* mediaRoster = BMediaRoster::Roster(&amp;status);<br />    if (!mediaRoster || status != B_OK) {<br />        ErrorAlert(&quot;Can&#39;t find the media roster.&quot;, status);<br />        mediaRoster = NULL;<br />        return status;<br />    }<br />    if (mediaRoster-&gt;Lock()) {<br />        // find the time source<br />        media_node time_source_node;<br />        status = mediaRoster-&gt;GetTimeSource(&amp;time_source_node);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Can&#39;t get a time source.&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br /><br />        // the AudioProducer connection<br /><br />        fAudioProducer = new AudioProducer(fChannelManager, this);<br />        status = mediaRoster-&gt;RegisterNode(fAudioProducer);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Unable to register AudioProducer node!&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br />        fAudioConnection.producer = fAudioProducer-&gt;Node();<br /><br />        // connect to the mixer<br />        status = mediaRoster-&gt;GetAudioMixer(&amp;fAudioConnection.consumer);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Unable to get the system mixer.&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br /><br />        mediaRoster-&gt;SetTimeSourceFor(fAudioConnection.producer.node,<br />                                      time_source_node.node);<br /><br />        // got the nodes; now we find the endpoints of the connection<br />        media_input mixerInput;<br />        media_output soundOutput;<br />        int32 count = 1;<br />        status = mediaRoster-&gt;GetFreeOutputsFor(fAudioConnection.producer,<br />                                                &amp;soundOutput, 1, &amp;count);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Unable to get a free output &quot;<br />                       &quot;from the producer node.&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br /><br />        count = 1;<br />        status = mediaRoster-&gt;GetFreeInputsFor(fAudioConnection.consumer,<br />                                               &amp;mixerInput, 1, &amp;count);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Unable to get a free input &quot;<br />                       &quot;to the mixer.&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br /><br />        // got the endpoints; now we connect it!<br />        media_format audio_format;<br />        audio_format.type = B_MEDIA_RAW_AUDIO;<br />        audio_format.u.raw_audio = media_raw_audio_format::wildcard;<br />        status = mediaRoster-&gt;Connect(soundOutput.source,<br />                                      mixerInput.destination,<br />                                      &amp;audio_format,<br />                                      &amp;soundOutput, &amp;mixerInput);<br />        if (status != B_OK) {<br />            ErrorAlert(&quot;Unable to connect nodes.&quot;, status);<br />            mediaRoster-&gt;Unlock();<br />            return status;<br />        }<br /><br />        // the inputs and outputs might have been reassigned during the<br />        // nodes&#39; negotiation of the Connect().<br />        // That&#39;s why we wait until after Connect() finishes<br />        // to save their contents.<br />        fAudioConnection.format = audio_format;<br />        fAudioConnection.source = soundOutput.source;<br />        fAudioConnection.destination = mixerInput.destination;<br /><br />        // Set an appropriate run mode for the producer<br />        mediaRoster-&gt;SetRunModeNode(fAudioConnection.producer,<br />                                    BMediaNode::B_INCREASE_LATENCY);<br />        // done mucking with the media roster<br />        mediaRoster-&gt;Unlock();<br />    }<br />    return status;<br />}<br /><br />status_t<br />ExampleWindow::StartNodes()<br />{<br />    status_t err = B_OK;<br />    BMediaRoster* mediaRoster = BMediaRoster::Roster(&amp;err);<br />    if (err != B_OK) {<br />        fprintf(stderr, &quot;ExampleWindow::StartNodes()&quot;<br />                        &quot; - error getting media roster: %s<br />&quot;,<br />                        strerror(err));<br />        mediaRoster = NULL;<br />    }<br /><br />    if (mediaRoster &amp;&amp; fAudioProducer)<br />        err = B_ERROR;  // error returned when locking fails<br />    if (mediaRoster-&gt;Lock()) {<br />        // figure out what recording delay to use<br />        bigtime_t latency = 0;<br />        err = mediaRoster-&gt;<br />              GetLatencyFor(fAudioProducer-&gt;Node(), &amp;latency);<br />        err = mediaRoster-&gt;<br />              SetProducerRunModeDelay(fAudioProducer-&gt;Node(), latency);<br /><br />        // start the nodes<br />        bigtime_t init_latency = 0;<br />        err = mediaRoster-&gt;GetInitialLatencyFor(fAudioProducer-&gt;Node(),<br />                                                &amp;init_latency);<br />        if (err != B_OK)<br />            printf(&quot;Can&#39;t get initial latency for audio producer node&quot;<br />                   &quot; - Error: %s<br />&quot;, strerror(err));<br /><br />        init_latency += estimate_max_scheduling_latency();<br /><br />        BTimeSource* tms, real, perf;<br />        tms = mediaRoster-&gt;MakeTimeSourceFor(fAudioProducer-&gt;Node());<br /><br />        real = tms-&gt;RealTime();<br />        perf = tms-&gt;PerformanceTimeFor(real + latency + init_latency);<br /><br />        tms-&gt;Release();<br /><br />        err = mediaRoster-&gt;StartNode(fAudioConnection.producer, perf);<br />        if (err != B_OK)<br />            printf(&quot;Can&#39;t start the audio producer&quot;<br />                   &quot; - Error: %s<br />&quot;, strerror(err));<br />        // done mucking with the media server<br />        mediaRoster-&gt;Unlock();<br />    }<br />    return err;<br />}<br /><br />void<br />ExampleWindow::StopNodes()<br />{<br />    status_t status = B_OK;<br />    BMediaRoster* mediaRoster = BMediaRoster::Roster(&amp;status);<br />    if (status != B_OK) {<br />        fprintf(stderr, &quot;ExampleWindow::StopNodes()&quot;<br />                        &quot; - error getting media roster: %s<br />&quot;,<br />                        strerror(status));<br />        mediaRoster = NULL;<br />    }<br />    if (fAudioProducer &amp;&amp; mediaRoster &amp;&amp; mediaRoster-&gt;Lock()) {<br />        // synchronous stop<br />        mediaRoster-&gt;StopNode(fAudioConnection.producer, 0, true);<br />        mediaRoster-&gt;Unlock();<br />    }<br />}<br /><br /></pre>

<p>Alright, I hope this article gets you up and running handling a media_server restart. If you have anymore questions, feel free to <a href="/user/stippi/contact">contact me</a>. Best of luck!</p><br class="clear" /><br class="giImageBlock-clear-both" /></div></div></div>