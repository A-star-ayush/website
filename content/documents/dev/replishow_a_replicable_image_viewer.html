+++
type = "article"
title = "RepliShow: A Replicable Image Viewer"
date = "2005-01-29T05:00:00.000Z"
tags = ["replicant", "translation kit"]
+++

<div class="field field-type-text field-field-body"><h3 class="field-label">Body</h3><div class="field-items"><div class="field-item"><div class="note-source-code">
<p><em>The original version of RepliShow was written by Seth Flaxman, and has been modified by Dr. Hartmut Reh.  The source discussed in this article can be found <a href="/files/HaikuNewsletter54Article1Archive1.zip">here</a>.</em></p>
</div>

<p>Today we&#39;ll be constructing a rather primitive application that displays images and is replicable. It will demonstrate two things: BeOS replicant technology and the Translation Kit.</p>  <p>Replicant technology is a standard part of BeOS, although it has not been widely used by many applications. You can see replicants in place in NetPositive and the Clock application that both ship with BeOS. You can tell something is replicable when it has a little dragger somewhere in its view, as shown below.</p>   <img src="/files/HaikuNewsletter54Article1Image1.jpg" alt="Figure 1: Replicant Dragger" title="Figure 1: Replicant Dragger" /> <br /><em> Figure 1: Replicant Dragger </em><br /><br /><br />   <p>When you click and drag the dragger to the desktop, the NetPositive view become embedded in the Desktop. In addition, the Container application (found in R5&#39;s Application Kit sample code folder) also serves as a repository for replicants.</p>   <img src="/files/HaikuNewsletter54Article1Image2.jpg" alt="Figure 2: Container" title="Figure 2: Container" /> <br /><em> Figure 2: Container </em><br /><br /><br />   <p>If you don&#39;t see the little dragger in the Clock or NetPositive view, replicants are probably turned off. Select &quot;Show Replicants&quot; from the Be Menu to turn them back on.</p>   <img src="/files/HaikuNewsletter54Article1Image3.jpg" alt="Figure 3: Show Replicants" title="Figure 3: Show Replicants" /> <br /><em> Figure 3: Show Replicants </em><br /><br /><br />   <p>In BeOS, anything that is derived from BView is replicable. This means that you cannot replicate BWindows. When designing an app that is going to be replicable, remember to put all the important code in your view, because your window will not be present when your view is embedded in the Desktop.</p>  <p>To make a view replicable in BeOS you need to implement three functions:</p>  <ol>  <li>A constructor that takes a BMessage as its only argument  </li><li>An instantiate function  </li><li>An archive function </li></ol>  <p>Strictly speaking, the constructor is not nescessary, but putting it in is good form. In addition to these functions, all replicable views need to be exported. To export a view, put a line that looks like this above it:</p>  <pre>class _EXPORT <em>ViewName</em><br /><br /></pre>  <p>...and at least a resource file containing the unique signature is necessary.</p>  <p>As I mentioned before, if a view is going to be replicable all the work needs to be done in the view,  not the window. Thus, our window will only have two functions: a Constructor() and a QuitRequested() function. Without the QuitRequested() function, the application would not quit when we close the window, because the QuitRequested() function is responsible for telling the application to quit when the window gets closed.</p>  <p>Now, let&#39;s get to the code. We need to write code containing RepliApp (derived from BApplication), RepliWindow (derived from BWindow) and RepliView (derived from BView).</p>   <img src="/files/HaikuNewsletter54Article1Image4.jpg" alt="Figure 4: RepliShow Project" title="Figure 4: RepliShow Project" /> <br /><em> Figure 4: RepliShow Project </em><br /><br /><br />   <p>Inside <em>RepliApp.cpp</em> you&#39;ll find the main() function. The main function is where our program starts,  so in it we must construct an application object and tell it to run. BApplication :: Run() does not return until the application is ready to quit.</p>  <pre>RepliApp :: RepliApp()<br />	  : BApplication(&quot;application/x-vnd.BeNews-RepliShow&quot;)<br />{<br />      RepliWindow *repliWindow = new RepliWindow();<br />      repliWindow -&gt; Show();<br />}<br /><br />int main()<br />{<br />     RepliApp  theApplication;<br />     theApplication.Run();<br />     return (0);<br />}<br /></pre>  <p>Everything here should be straightforward. We create the RepliApp with a signature that uniquely describes it.  Next, we create the RepliWindow and show it.</p>  <pre>RepliWindow :: RepliWindow()<br />	         : BWindow(BRect(100,100,350,350), &quot;RepliShowWindow&quot;,<br />			           B_TITLED_WINDOW, B_NOT_RESIZABLE | B_NOT_ZOOMABLE)<br />{<br />    RepliView *replView = new RepliView(Bounds());<br />    AddChild(replView);<br />}<br /><br />bool RepliWindow::QuitRequested()<br />{<br />    be_app-&gt;PostMessage(B_QUIT_REQUESTED);<br />    return true;<br />}<br /></pre>  <p>The RepliWindow constructor passes four arguments along to BWindow: the window frame, title, type, and flags. Type tells BeOS how the window should look: whether it should be floating, should be modal, should have a border, etc.  Lastly, the flag tells how the window should be resizable. In our case, we have set the window to be neither resizable nor zoomable.</p>  <p>Now, let&#39;s look at the RepliView class:</p>  <pre><br />RepliView :: RepliView(BRect frame)<br />	   : BView(frame, &quot;RepliShowView&quot;, B_FOLLOW_NONE, B_WILL_DRAW)<br />{<br />    fBitmap 	= NULL;<br />    fReplicated = false;<br /><br />    frame.left = frame.right - 7;<br />    frame.top = frame.bottom - 7;<br />    BDragger *dragger = new BDragger(frame, this, B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);<br />    AddChild(dragger);<br />}<br /><br />RepliView :: RepliView(BMessage *archive)<br />	    : BView(archive)<br />{<br />    fReplicated	= true;<br />    fBitmap 	= new BBitmap(archive);<br />}<br /><br />RepliView :: ~RepliView()<br />{<br />    delete fBitmap;<br />}<br /></pre>  <p>Our first three functions are two constructors and one destructor. The first of our two constructors is the one that is used when we create the view manually. The second constructor takes a BMessage and is used when the view is replicated. The BMessage returns data that we stuffed into it in our archive function. The first constructor sets fBitmap to NULL and creates a BDragger. The frame of the BDragger is currently hardcoded to 8 pixels by 8 pixels. Last, we set fReplicated to false. We use fReplicated in our MessageReceived() function when we decide whether to resize the view or to resize the window. The replicant constructor attempts to create a BBitmap from the data stored in the message. This is called unarchiving the BBitmap. BBitmap takes a BMessage as one of its constructors and looks in the BMessage for the data we would usually pass to the constructor: the colorspace, the frame, its contents, etc. The replicant constructor of RepliView is much like the replicant constructor of the BBitmap. It unarchives the view. Many replicants store other things like what text was being displayed in the message and then unarchive this information.</p>  <pre>void RepliView::Draw(BRect)<br />{<br />    if(fBitmap)  DrawBitmap(fBitmap, B_ORIGIN);<br />}<br /></pre>  <p>The Draw() function draws the bitmap on the view.</p>  <pre>void RepliView :: MessageReceived(BMessage *msg)<br />{<br />    switch(msg-&gt;what)<br />    {<br />        case B_SIMPLE_DATA:<br />        {<br />	entry_ref ref;<br />	msg-&gt;FindRef(&quot;refs&quot;, &amp;ref);<br />	BEntry entry(&amp;ref);<br />	BPath path(&amp;entry);<br /><br />	delete fBitmap;<br />	fBitmap = BTranslationUtils::GetBitmap(path.Path());<br /><br />	if(fBitmap != NULL)<br />	{<br />	    BRect rect = fBitmap-&gt;Bounds();<br />	    if(!fReplicated)  Window() -&gt; ResizeTo(rect.right, rect.bottom);<br />	    ResizeTo(rect.right, rect.bottom);<br />	    Invalidate();<br />	}<br />        }<br />        break;<br /><br />        case B_ABOUT_REQUESTED:<br />        {<br />            AboutRequested();<br />        }<br />        break;<br /><br />        default:<br />	BView::MessageReceived(msg);<br />        break;<br />    }<br />}<br /><br /></pre>  <p>In the MessageReceived() function we look for a message with what type B_SIMPLE_DATA. We get that message when a user drops an image on the view. If we find the message, we look for an entry_ref named &quot;refs&quot; inside the message. Next, we convert that ref to a BPath and pass that path along to a static function in the BTranslationUtils class. Before calling this function we delete the bitmap so that we don&#39;t leave memory lying around.</p>  <p>BTranslationUtils :: GetBitmap() is a convenience function that takes a path to a file and attempts to find a translator that knows to handle that file. If it finds a translator that can handle the file it returns the newly created bitmap, otherwise it returns NULL. If we get a bitmap from GetBitmap() we check to see if we are replicated or if we are in a regular BWindow. If replicated, we resize the view. Otherwise, we resize the window and then we resize the view. Last we call Invalidate() to make sure the new BBitmap gets drawn.</p>  <p>A further message the RepliView is able to handle is the what type B_ABOUT_REQUESTED. This message is sent when clicking the little dragger using the right mouse button. We get a pop-up menu offering to delete the replicant or to obtain informations about the RepliShow.</p>   <img src="/files/HaikuNewsletter54Article1Image5.jpg" alt="Figure 5: Replicant Pop-Up Menu" title="Figure 5: Replicant Pop-Up Menu" /> <br /><em>  Figure 5: Replicant Pop-Up Menu </em><br /><br /><br />   <p>If B_SIMPLE_DATA and B_ABOUT_REQUESTED are not the what type of the BMessage we pass the message along to BView to handle.</p>  <p>The function AboutRequested() is responsible for displaying a BAlert() containing the requiered informations.</p>  <pre>void RepliView  :: AboutRequested()<br />{<br />     BAlert *alert = new BAlert(&quot;&quot;, &quot;RepliShow from Seth Flaxman&quot;, &quot;OK&quot;);<br />     alert-&gt;Go();<br />}<br /></pre>   <img src="/files/HaikuNewsletter54Article1Image6.jpg" alt="Figure 6: B_ABOUT_REQUESTED" title="Figure 6: B_ABOUT_REQUESTED" /> <br /><em>  Figure 6: B_ABOUT_REQUESTED </em><br /><br /><br />   <pre>status_t RepliView :: Archive(BMessage *archive, bool deep) const<br />{<br />    BView :: Archive(archive, deep);<br />    archive -&gt; AddString(&quot;add_on&quot;, &quot;application/x-vnd.BeNews-RepliShow&quot;);<br />    archive -&gt; AddString(&quot;class&quot;, &quot;RepliShow&quot;);<br /><br />    if(fBitmap)<br />    {<br />        fBitmap-&gt;Lock();<br />        fBitmap-&gt;Archive(archive);<br />        fBitmap-&gt;Unlock();<br />    }<br />    // archive -&gt; PrintToStream();<br />    return B_OK;<br />}<br /><br />BArchivable *RepliView :: Instantiate(BMessage *data)<br />{<br />    return new RepliView(data);<br />}<br /></pre>  <p>The Instantiate() and Archive() functions handle instantiating the view after it has been archived and archiving the view (so that it can be instantiated later), respectively. In more understandable terms, the Instantiate() function returns a copy of the RepliView class, constructed with the constructor that takes a BMessage. The Archive() function is the function that adds to that BMessage. First, we pass the BMessage along to our parent view so it can add stuff to the message. Next, we add a string containing &quot;add_on&quot;, which holds the application&#39;s signature, and then a string containing &quot;class&quot;, which holds the name of the class.  Last, we lock the bitmap and tell it to archive itself in the message. The archived BBitmap is added to the archived view now containing all information.</p>  <p>Let&#39;s have a look at the archive using the PrintToStream() function:</p>  <pre>BMessage: what = ARCV (0x41524356, or 1095910230)<br />    entry          class, type=&#39;CSTR&#39;, c=2, size=10, data[0]: &quot;RepliView&quot;<br />                                            size=10, data[1]: &quot;RepliShow&quot;<br />    entry          _name, type=&#39;CSTR&#39;, c=1, size=14, data[0]: &quot;RepliShowView&quot;<br />    entry         _frame, type=&#39;RECT&#39;, c=1, size=16, data[0]: BRect(l:0.0, t:0.0, r:250.0, b:250.0)<br />    entry         _flags, type=&#39;LONG&#39;, c=1, size= 4, data[0]: 0x20000000 (536870912, &#39; &#39;)<br />    entry         _views, type=&#39;MSGG&#39;, c=1, size= 0,<br />    entry         add_on, type=&#39;CSTR&#39;, c=1, size=35, data[0]: &quot;application/x-vnd.BeNews-RepliShow&quot;<br /><br /></pre>  <p>The archive contains three classes:</p> <ul>  <li>&quot;RepliView&quot; - the view class name of the RepliShow application,  </li><li>&quot;RepliShow&quot; - defined in our Archive() function (AddString...).  </li><li>&quot;BBitmap&quot; - the bitmap </li></ul>  <p>The entry_name is &quot;RepliShowView&quot;, the name of the class &quot;RepliView&quot;.</p>  <p>At the end of the archive we find the raw bitmap data.</p>  <p>When creating your own replicant applications, remember to create a resource file for the application. If the application does not link against a resource file, it will not know its signature and when Tracker or Container tries to replicate it, neither one will be able to find your application.</p>   <img src="/files/HaikuNewsletter54Article1Image7.jpg" alt="Figure 7: Resource File" title="Figure 7: Resource File" /> <br /><em> Figure 7: Resource File </em><br /><br /><br />   <p>Well, now the application should work. We can drop an image on it, when it is in regular mode, then replicate it and the image will still be there--even after quitting the RepliShow application. Also, we can drop an image on it in replicant mode, then reboot (or if the replicant is part of the Tracker, just restart the Tracker) and the image will still be there. Pretty neat, huh? My hope is that this tutorial will serve as a starting point for enterprising developers out there who want to use replicant technology to do cool stuff. With that in mind, below is a list of some ideas for other applications that could use replicants. In addition, I hope that all reading this will post their own ideas in the comments section. Replicants can be fun, but there are lots of practical uses for them, too. Without further ado, here&#39;s my quick list of ideas:</p>  <ul>  <li>Expand RepliShow so that it connects to someone else&#39;s computer running RepliShow and sends it the image that was just dropped, then that computer displays the image.  </li><li>Make RepliShow into a whiteboard type application where a user on one side sketches their ideas, then they are sent over the internet and displayed on someone else&#39;s computer. With replicants you could have five people giving you their ideas at once, each one in a different box that&#39;s stuck to your Desktop.  </li><li>Make RepliShow fetch a cartoon (using FetchUrl) and display that cartoon on the Desktop. </li></ul>

<h4>Final Remarks</h4>

<p>When developing your replicant it&#39;s a good idea to test its behaviour using the ShelfInspector application and setting the drop zone to the Container window instead of to the Desktop window. To remove all obsolete data simply delete the file <em>Container_data</em> located in <em>/boot/home/config/settings/</em>.</p>  <p>If you are working with the plain Desktop window as a shelf view you will not immediately see changes made to your replicant during the development phase. The Tracker rejects changes made to the replicant view because the add-on/library defining the replicant is still loaded; however, changes are updated after restarting the Tracker. If you are still running into problems remove the file <em>tracker_shelf</em> (from <em>/boot/home/config/settings/</em>)--all Tracker-replicants will be removed.</p>   <img src="/files/HaikuNewsletter54Article1Image8.jpg" alt="Figure 8: Helper Apps" /> <br /><em> Figure 8: Helper Apps </em><br /><br /><br />

<p>If you intend to develop replicants more comfortably, use the extended versions of the above mentioned programs.</p>  <p>Stay tuned for the following issues!</p>

<img src="/files/HaikuNewsletter54Article1Image9.jpg" alt="Teaser" /> <br class="clear" /><br class="giImageBlock-clear-both" /></div></div></div>