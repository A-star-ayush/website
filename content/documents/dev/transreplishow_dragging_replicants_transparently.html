+++
type = "article"
title = "TransRepliShow: Dragging Replicants Transparently"
date = "2005-03-28T05:00:00.000Z"
tags = ["replicant"]
+++

<div class="field field-type-text field-field-body"><h3 class="field-label">Body</h3><div class="field-items"><div class="field-item"><div class="note-source-code">
<p><em>This article follows up on Dr. Reh&#39;s previous newsletter article, </em><a href="/documents/dev/replishow_a_replicable_image_viewer">RepliShow: A Replicable Image Viewer</a><em>.  The code discussed is available <a href="/files/HaikuNewsletter56Article1Archive1.zip">here</a> for your convenience.</em></p>
</div>

<p>Just remember Seth Flaxman&#39;s RepliShow: While dragging the replicant you only see the border lines of an empty rectangle - not very Be-like. However, only a few lines of code are necessary to obtain a rectangle containing the dragged image and looking transparently. Because the dragging action is managed by the BDragger class we need to do some subclassing. We create a new RepliDragger class inherited from BDragger. When this is done we override the hook function virtual void MouseDown( BPoint where ):</p>  <pre>void RepliDragger ::MouseDown( BPoint where )                            // mouse down<br />{ <br />    BPoint cursor;<br />    uint32 buttons;<br />	<br />    SetMouseEventMask( B_POINTER_EVENTS, 0 );                            // view can receive mouse-events<br />    GetMouse(&amp;cursor,&amp;buttons);<br /><br />    if ( (fBitmap != NULL) &amp;&amp; (fArchive != NULL) &amp;&amp; (buttons &amp; B_PRIMARY_MOUSE_BUTTON) )<br />    {<br />        BPoint origBitmap;<br />        BRect bitmapRect  = fBitmap -&gt; Bounds();                         // get boundaries of image<br />        BBitmap *bitmap  = new BBitmap(bitmapRect, B_RGB32,true);        // create bitmap for drag-and-drop<br />        memcpy(bitmap-&gt;Bits(), fBitmap-&gt;Bits(), fBitmap-&gt;BitsLength());  // copy bitmap<br />        origBitmap = BPoint(bitmapRect.Width(),bitmapRect.Height());     // position relative to bitmap<br />        origBitmap = origBitmap - BPoint(7-where.x, 7-where.y);<br />        DragMessage( fArchive, bitmap, B_OP_BLEND, origBitmap, NULL); 	<br />    }<br />	<br />    BDragger :: MouseDown(where);                                        // BDragger mouse down events<br />}<br /></pre>    <p>void DragMessage(BMessage *message, BBitmap *image, drawing_mode dragMode, BPoint offset, replyTarget = NULL) is responsible for the drag-and-drop handling. message is a BMessage object containing all information that will be dragged and dropped to the BShelf container view. In our special case the message is fArchive, our archived view. Using the dragMode B_OP_BLEND lets you drag the BBitmap image transparently around. Because the bitmap is automatically freed when the message is dropped, we need to duplicate the original bitmap. BPoint offset locates the hot spot within the image (in the bitmap&#39;s coordinate system). This is the point that&#39;s aligned with the location passed to MouseDown(). And last but not least we call BDragger :: MouseDown(where) to handle all remaining mouse-down events, e.g. BDragger&#39;s pop-up menu.</p>  <p>A small problem is arising: first we call DragMessage() and then BDragger::MouseDown().  However, MouseDown() is responsible for initiating the Archive(BMessage *archive, bool deep) procedure, therefore DragMessage() is missing the archived view. We must guarantee that the view is archived before we call DragMessage() - we need a valid fArchive and a valid fBitmap.</p>  <pre>void RepliDragger :: GetBitmap(BBitmap *bitmap)					<br />{ <br />     fBitmap = bitmap;	<br />}<br /><br />void RepliDragger :: GetArchive(BMessage *archive)					<br />{ <br />    fArchive = archive;	<br />}<br /></pre>  <p>Every time we are going to create a replicant out of our view, this view has to call GetArchive(), or GetBitmap() when changing our image. Then RepliDragger will be equipped with a valid pointer to perform DragMessage().</p>  <p>This was the main work to do, excepting some small modification left to TransRepliView.</p>  <p>The TransRepliView class holds two constructors. Both must create the RepliDragger class using CreateDragger() - we have done subclassing and are not able to archive the new RepliDragger class. Then we simulate a dragged replicant by archiving our view, setting the archive message&#39;s command to B_ARCHIVED_OBJECT, and sending the message to a remote application using the above mentioned DragMessage() function. If the remote application has a BShelf object, the BShelf will pick up the message (through a BMessageFilter) and pass it to the hook function. Of course we must inform RepliDragger about the newly archived view: fRepliDragger -&gt; GetArchive(&amp;fArchive).</p>  <pre>TransRepliView :: TransRepliView(BRect frame) <br />	             : BView(frame, &quot;TransRepliShowView&quot;, B_FOLLOW_NONE, B_WILL_DRAW)<br />{<br />    fReplicated = false;<br />    fBitmap = NULL;	<br />    CreateDragger();<br />}<br /><br />TransRepliView :: TransRepliView(BMessage *archive) <br />	             : BView(archive)<br />{<br />    fReplicated = true;<br />    fBitmap = new BBitmap(archive);<br />    CreateDragger();<br />	<br />    fArchive = BMessage( B_ARCHIVED_OBJECT);	<br />    Archive(&amp;fArchive,true);	<br />    fRepliDragger -&gt; GetArchive(&amp;fArchive);<br />}<br /></pre>  <p>CreateDragger() is responsible for the new RepliDragger() class and telling the class about a new bitmap.</p>  <pre>void TransRepliView :: CreateDragger()<br />{<br />    BRect frame = Bounds();<br />    frame.left      = frame.right - 7;<br />    frame.top      = frame.bottom - 7;<br />	<br />    fRepliDragger = new RepliDragger(frame, this);<br />    AddChild(fRepliDragger);	<br />    fRepliDragger -&gt; GetBitmap(fBitmap);<br />}<br /><br /></pre>  <p>When a new image was dropped onto the view we must tell the RepliDragger about this, so the MessageReceived() hook function needs four additional lines of code when handling B_SIMPLE_DATA:</p>  <pre>    ...<br />    fArchive = BMessage( B_ARCHIVED_OBJECT);<br />    Archive(&amp;fArchive,true);				<br />    fRepliDragger -&gt; GetArchive(&amp;fArchive);<br />    fRepliDragger -&gt; GetBitmap(fBitmap);<br /><br /></pre>          <p>Finally a snapshot showing the fearless leader floating transparently over the desktop:</p>   <img src="/files/HaikuNewsletter56Article1Image1.jpg" alt="Fearless Leader" title="Fearless Leader" /> <br class="clear" /><br class="giImageBlock-clear-both" /></div></div></div>