+++
type = "article"
title = "Division of Labor: Kits, Libraries, Servers, and Teams"
date = "2001-12-30T04:00:00.000Z"
tags = ["team", "classes", "kits", "libraries"]
+++

<div class="field field-type-text field-field-body"><h3 class="field-label">Body</h3><div class="field-items"><div class="field-item"><p><strong>Note:</strong> this article was written by Daniel Reinhold.</p><p>   I remember several years back (about spring &#39;96) when I first discovered the joys of the internet and was amazed at the sheer number of goodies to be plucked. This was well before BeOS Intel, so I spent alot of time downloading Windows shareware programs. After a few months, however, the excitement died down considerably when I discovered an unfortunate truth: most of those shareware programs were complete crap. If they didn&#39;t crash within a few minutes, their interface was so awkward that I just couldn&#39;t stand to use them. </p><p> There are many styles of bad interface, but one of the more common (and in many ways, humorous) of the lot is what I call the &quot;thin geek layer&quot;. This is where the interface consists of a myriad of buttons (often tiny) and/or complex nested menus containing long lists of items whose labels seem to pretty much match the underlying function calls. It makes me grin to see such programs, because I can almost tell, by looking at the front end, what the back end must be like. I have a pretty clear feeling that when I click on a button called &#39;RasterPunkFoobitz&#39; that it directly calls a rasterPunkFoobitz() function. The programmers who write these kinds of programs are obviously so enamored (or distracted) with implementing all the whiz-bang functionality that they don&#39;t give much thought or effort into the idea of presenting an interface designed with the user in mind. </p><p> This is the sort of thing that makes user interface designers hyperventilate and turn blue. The desired goal for any good interface is to present a world view that corresponds with what the user cares about and the set of tasks he wants to carry out. The back end should implement this by whatever means necessary to fulfill the illusion. </p><p> Creating a good user interface isn&#39;t just the task of application programming. It&#39;s also the concern of library design -- particularly when it&#39;s part of an application framework. In this case, the users are developers and the interface is the API (Application Programming Interface). An API must obey all the rules of good user interface just as surely as any user program if it is to going to be effective and usable. </p><h2> Implementing the BeOS API </h2><p> The BeOS API, I am happy to say, is a very good API -- that is, a very good design. Because of this, the front end presented to developers -- the various kits with their associated headers, class definitions, documentation -- do not necessarily correspond one to one with the back end implementation -- libraries, add-ons, servers.  </p><p> While this is certainly a good thing from a design stand point, it does create a certain confusion with regards to how we, the Haiku project, implement the BeOS API. Because, as implementors, we must be just as concerned with the back end as the front. Even more so, since the front end (the API specs) are already established and it is the back end that must be recreated from scratch. </p><p> The confusion arises when people look at the Haiku programming teams that we have set up and try to understand how their particular &quot;pet&quot; concern fits in. Oh sure, for the most part, the division of labor into the various teams is quite obvious and makes sense: the Printing team works on printing, the Network team implements networking, and so on. There is no problem with this. But where do drivers fit in? What about missing kits? For example, why is there no team for the Support Kit? Where&#39;s the team for OpenGL? Why is there only one team to handle both the Application Kit and the Interface Kit? </p><p> One answer might be that we don&#39;t know what we&#39;re doing. Since there&#39;s probably an element of truth in that statement, we&#39;ll disregard that nasty little observation for now and move on to more useful explanations (he says slyly with a large grin on his face). </p><h2> Teams </h2><p> The large diversity of tasks and skills required to implement an OS naturally require that you break the whole thing down into a collection of parts. You put different people with specific skills into their own area of expertise. When several people work together to implement one particular piece of functionality, that is called a team. The teams co-operate, of course, but it&#39;s quite amazing (and a testimonial to the good design of the BeOS API) the extent to which these various teams can work independently as their own little islands. </p><p> These teams are about the business of creating the back end. The front end, i.e. the BeOS API, acts as a projec spec and, as a design element, is basically done. We may make a few very, very minor alterations on the road to R1, but, for all practical purpose, this can be considered finished. </p><p> Now, what exactly are the parts to be written? Well, at the risk of sligthly oversimplifying the situation, you could say that the BeOS consists of three major parts: the kernel, the drivers, and the application framework. The kernel is, well, the kernel. The drivers are kernel add-ons such as video card and other hardware drivers and all file systems. The application framework defines userland. It&#39;s where all the apps live with their associated windows, loopers, messages, etc. </p><p> Let&#39;s focus on the application framework. For the BeOS, this has a C++ interface. The vast majority of functionality is placed into C++ classes. Lots of classes.  </p><h2> Classes </h2><p> Pretend for a moment that we have the complete set of classes before us in one long list (no, I haven&#39;t actually compiled such a list, but even if I had, I wouldn&#39;t put the whole thing here, for goodness sake).: </p><pre>BApplication<br />BWindow<br />BView<br />BMessage<br />BLooper<br />BHandler<br />BInvoker<br />BRoster<br />BClipboard<br />BPoint<br />BRect<br />BBox<br />BButton<br />BControl<br />BAlert<br />BFont<br />BPicture<br />BPolygon<br />BMenu<br />BBitmap<br />BShape<br />BScreen<br />BTextView<br />BStatusBar<br />BString<br />BList<br />BFile<br />BDirectory<br />BEntry<br />BNode<br />BQuery<br />BPath<br />BMimeType<br />BVolume<br />BSymLink<br />BFlattenable<br />BArchivable<br />BNetBuffer<br />BNetAddress<br />...<br />(many others omitted)<br />...<br /></pre> You get the idea, there&#39;s alot of &#39;em. <p> Now consider the task of re-writing all these classes, which is precisely what the Haiku project is doing. We start at the top and go down the list, one by one, and implement each class, right? Bzzzt. Wrong. Off with your head. We may be a little dumb, but we are not stupid. </p><p> Naturally, most of these classes can be clustered together into related groups that help implement a particular type of functionality. BPoint, BRect, BFont, and a score of other related graphics classes would naturally be written by folks who have expertise in that area. Likewise, BFile, BDirectory, BEntry, etc. call for a different set of knowledge and skills. This is not to say that some people couldn&#39;t work on all of these (some probably have the talent to do so). But even then, you want focus. You want for each person to be able to concentrate effectively on each set of classes they must implement. </p><p> Ok, I&#39;m sure that no one disputes what I&#39;ve said about this. Yes, you should divide up the application framework into the various different pieces of functionality, find programmers who have the corresponding skills and interest, and then assign them to that piece. Get several of them working together and you have a programming team. No one argues with this. </p><p> But what exactly are the pieces? What are these natural divisions I have spoken of that define the different areas of functionality? The BeOS kits, you might well answer. Well...no, not really. That&#39;s where the confusion comes in.  </p><p> You see, the programming teams are all about creating the back end. The kits, however, are a description of the front end. </p><h2> Kits </h2><p> It&#39;s tempting to say that the kits are a marketing fiction. That&#39;s probably going a bit too far. But the point is, those kits are really just a description in the BeBook to help programmers understand how to use the BeOS API. They are Be&#39;s attempt to organize and explain all those classes: how they work, how to use them, how they inter-relate, etc. Their particular organization of the kits wasn&#39;t written in the stars -- they could well have organized it somewhat differently. </p><p> Since they describe the front end, those kits do not necessarily represent the only or even the best way of dividing up the work of implementing the classes. The BeOS API is no &quot;thin geek layer&quot; -- what you (the developer) see in the kits is what you need to see in order to get your tasks accomplished. But as implementors of the API, we have to organize the work in a way that best suits the needs, desires, and skills of those who are actually in the trenches, filling out the back end. </p><p> Having said all this, in reality, those kits often *do correspond* to a natural area of functionality, even as far as implementation is concerned. For example, Be found it convenient to divide up all the classes and headers for the Media related stuff into one unit which they call the Media Kit. Likewise, we find it convenient to put all the tasks involved in re-creating the Media Kit into one team. </p><p> So you see, the kits as described by Be in the BeBook don&#39;t neatly fit into the task of implementing the BeOS. They don&#39;t *perfectly* match our requirements; on the other hand, they do match to a certain extent. It&#39;s a near miss. Because of this, we often use the term &quot;kit&quot; to describe a piece of implementation that we&#39;re working on, which only confuses the matter. To muddy the waters even further, we have used the term &quot;kit&quot; to label each of the high-level folders in the CVS repository. Thus, when looking for the project source code, you find them organized into folders called &quot;kernel_kit&quot;, &quot;app_kit&quot;, &quot;game_kit&quot;, etc. </p><p> We&#39;re not trying to intentionally confuse the issue. We&#39;re just struggling for the appropriate terminology to describe what we&#39;re doing. The term &quot;kit&quot; is there from the BeBook, it&#39;s simple, well-known, and reasonably catchy. You tend to use what you have. </p><h2> Libraries  </h2><p> While a developer needs to have the API documented so he can understand how to use it, and the have headers available so that he can compile his code, the actual functionality is provided by the libraries. Since the libraries are the back end, there is no required correspondence to the kits. So is there a correspondence? Again, yes and no. Be sometimed matches a library one-to-one with a kit -- e.g. the Network kit is implemented in the libnet.so library. But in other cases, there is no set correspondence. </p><p> Consider again the imaginary list of all BeOS classes referred to above. Had Be wanted to, they could have compiled all of them into one big, mondo library -- say, libeverything.so. That certainly would have been a very simple setup and it would have worked. But it does have disadvantages: essentially every part of the OS would have to be loaded in memory at all times, even if certain parts were hardly ever used by particular users. Since almost all parts of the OS are used at some point, this isn&#39;t as bad as it seems. Still, it offends the sensibilties of many programmers who prefer a more fine-grained approach. Another disadvantage, from Be&#39;s perspective, would be that every time someone recompiled a new class, regardless of how peripheral its duties, the whole library would have to be recompiled. Not very good from a project management stand point. </p><p> As a matter of course, Be took something of a middle ground. Many of the kits are implemented as separate libraries, but there are a couple of big, all-encompassing libraries at the core. There is libroot.so, the &quot;root&quot; library, which exports all the kernel functions that are available in userland. Then there is the mother of all libs, libbe.so, the &quot;Be&quot; library, which implements all the core functionality of the application framework. libbe.so contains all the guts needed for the Application Kit, the Interface Kit, the Storage Kit, the Support Kit, and a few others. It&#39;s a biggy.  </p><h2> Servers </h2><p> One of the distinctive features of the BeOS is its client/server architecture. This means that most of the OS functionality is delivered at run time by servers -- background processes that are started at boot up and are always running. </p><p> The most common example is the app_server which works in tandem with your application to provide all the graphics and messaging for your application&#39;s windows and views. Note that the app_server manages both the graphics operations (described in the Interface Kit) and the windowing/messaging operations (described in the Application Kit). This is why we have only one team dedicated to both kits: the reality is the back end functions of the app_server completely cut across both kits (Application and Interface) and trying to handle this as two teams would just be duplicating effort. </p><p>  Nor does every kit have a server. There is no game server or storage server, etc. The media kit actually has two: media_server for normal media applications, and the media_addon_server for media addons. </p><p>&nbsp;</p><h2>Tying it all together</h2><p>OK, let&#39;s summarize a bit. We have three basic entities to deal with in order to organize the work of recreating the BeOS: the kits, the libraries, and the servers. The kits are the interface spec, designed by Be and adopted by Haiku to serve as the project guidelines. The libraries are the actual compiled code that supply the OS functionality. The servers are userland processes that dish out the functionality to client programs at run time. </p><p>&nbsp;</p><p> Finally, we have the teams -- groups of programmers united to implement each particular piece of the OS. They must organize the other three entities together in a way that makes sense for the type of back end work they are engaged in. </p><p> To try to visualize the relationship between these, here is a table that lists each kit from the BeBook and then maps the corresponding library, server, and designated team for it:  </p><pre>Kit             Library             Server          Team<br />===================================================================<br />Application     libbe.so            app_server      App/Interface<br />Device          libdevice.so        (None)          (None)<br />Game            libgame.so          (None)          Game<br />Interface       libbe.so            app_server      App/Interface<br />Kernel          libroot.so          (None)          Kernel<br />Mail            libmail.so          mail_daemon     Networking<br />Media           libmedia.so         media_server    Media<br />Midi            libmidi.so          midi_server     MIDI<br />Network         libnet.so           net_server      Networking<br />OpenGL          libGL.so            (None)          (Game?)<br />Storage         libbe.so            (None)          Storage<br />Support         libbe.so            (None)          (None)<br />Translation     libtranslation.so   (None)          Translation<br />Input Server    libbe.so            input_server    Input Server<br />Screen Saver    libscreensaver.so   (None)          ScreenSaver<br />Deskbar         libtracker.so       DeskBar<br />Tracker         libtracker.so       Tracker<br /></pre> <p> There are some awkward gaps in the table above, but if you reorganize the table with respect to teams, or libraries, or servers, you get the same results (just different gaps). These various elements all have a notion of partitioning the components of the OS, but each with distinctive viewpoints. Change the viewpoint, and you get a slightly different organizational scheme. </p><p>&nbsp;</p><h2>Filling in the gaps</h2><p>Where is the Printing team in the table above? Actually, there is no Printing Kit in the BeOS API -- only a single class called BPrintJob which is in the Interface Kit. Deskbar and Tracker don&#39;t have an assigned team either, but these are already taken care of in the OpenTracker project, so we needn&#39;t be concerned about it. </p><p> The Support Kit does not have a team, but does it really need one? That kit isn&#39;t really a kit like all the others that are organized according to common purpose and function. Instead, the Support Kit is just a hodge-podge of classes that didn&#39;t find a place within any other kit. It&#39;s just a convenient name for all the orphaned classes. Some, such as BArchivable and BFlattenable are pertinent to the sending of BMessages and, thus, are being implemented by the App/Interface team. Others are generic classes, such as the BString class, that could be implemented by any team member. </p><p> Where is OpenGL? That hasn&#39;t been decided yet. No specific team has been setup to implement this, although there has been discussion that it could be handled by the Game Kit team. Or perhaps the App/Interface team will do it instead. Or maybe a separate team will be factored out and the Game Kit and App/Interface teams can then use and build on the base implementation. More than likely, this will not be dealt with in R1.  </p><p> And what about the parts outside of the application framework? This is probably the least well documented aspect of the project. Basically, most functionality not part of userland will be implemented by the kernel team. There can be exceptions, particularly for add-ons -- e.g. BFS (the Be File System) has its own programming team. </p><p> Drivers, on the other hand, will likely be taken up by whoever is best equipped to do the work. The basic drivers for the mouse, keyboard, hard disk and CDs (at least the initial versions) will be written by members of the kernel team. An intial, baseline graphics driver will come from the App/Interface team. And the members of the Printing team are writing the printer drivers. Really, anyone who has the skills and motivation can jump in on this work. We could set up a &quot;Drivers&quot; team, but there is probably little point. The main purpose of a programming team is to join together the collective brains and efforts of the members towards a specific task. But each type of driver tends to require very detailed knowledge about a specific area. So members of a Drivers team might well have only their collective membership in common. </p><p> In short, it&#39;s a bit of a mess. The inter-relationships between the various elements is something of a cats cradle. The teams must recreate all the kits in the API, but they are actually implemented in the libraries and servers. Each kit does not necessarily correspond to a specific library, each library does not necessarily have a corresponding server, each team does not necessarily implement either a specific library or kit. Clear as mud, no? </p><p> Ultimately, how we divide up all the various implementation tasks comes down to the skills, interests, and participation of the project members. For example, right out of the gate, Haiku will have far better printing support than the BeOS ever did. This is not because we sat down at the beginning and decided, &#39;dammit, we&#39;re going to excel at printing in Haiku&#39;. It&#39;s just because we happened to have attracted the attention and help of several programmers with long experience with printing and printer drivers. </p><p> If you see an unfilled gap in what I&#39;ve presented in this article, and you have the programming chops to make it real, then join the project and make it happen. I promise you that you&#39;ll be welcomed and no one will get in your way.</p><br class="clear" /><br class="giImageBlock-clear-both" /></div></div></div>