+++
type = "article"
title = "Booting Haiku remotely over a local network."
date = "2010-01-12T22:26:20.000Z"
tags = []
+++

The root Haiku disk image (raw variant) can be booted remotely over the local network as of recent versions. This is especially useful when an architectures boot and kernel issues need to be troubleshot.<br><br>
In the example below we will cover remote booting Haiku on various architectures. At the moment this is mostly geared toward developers.<br>
<h3>Pre-requirements</h3>
<ul>
<li><b>Required:</b> <a href='http://www.haiku-os.org/guides/building/pre-reqs'>Linux build tools</a></li>
<li><b>Required:</b> <a href='http://www.haiku-os.org/guides/building/get-source'>Haiku source code and build environment</a></li>
<li><b>Required:</b> Enough memory on the test system. (Size of haiku.image + 256MB should work)</li>
<li><b>Required:</b> haiku.image file generated by <i>` jam -q haiku-image `</i></li>
<li><b>Optional:</b> TFTP Server (for pushing out boot loader on some architectures)</li>
</ul>
<br>

<h3>The remote disk server</h3>
The Haiku sources include a remote disk server which listens for UDP requests from the Haiku boot loader. When a network UDP request for the disk image is received from the boot loader, it is provided over the network to the test system.<br>

<ul>
<li><h4>Spawning the remote disk server</h4>
Starting the remote disk server is fairly straight forward using the Jam tool.  Starting the remote disk server should be performed prior to starting the boot loader on the test system.

<pre class="terminal">$ jam -q run ':remote_disk_server' ./generated/haiku.image
...found 109 target(s)...
...updating 1 target(s)...
RunCommandLine1 <unique!target>run_0
</pre>
<div class="alert alert-info">The remote disk server will need to be killed via <span class="key">CTL</span>+<span class="key">c</span> and re-spawned each time the haiku disk image changes.</div>
</li>
<li><h4>Remote disk server request</h4>
After the remote disk server receives a request, it will begin to push the provided disk image out to the Haiku boot loader running on the test system...
<pre class="terminal">
HELLO request
READ request: offset: 0, 512 bytes
READ request: offset: 1024, 512 bytes
READ request: offset: 2048, 512 bytes
READ request: offset: 3072, 512 bytes
READ request: offset: 4096, 512 bytes
READ request: offset: 5120, 512 bytes
READ request: offset: 6144, 512 bytes
READ request: offset: 7168, 512 bytes
READ request: offset: 0, 512 bytes
READ request: offset: 67108864, 232 bytes
READ request: offset: 67110912, 1024 bytes
READ request: offset: 67111936, 1024 bytes
READ request: offset: 67110912, 1024 bytes
READ request: offset: 67111936, 1024 bytes
.
.
</pre>
</ul>

<h3>Booting the system</h3>
Booting methods vary from architecture to architecture.  Generally the platform's boot loader should perform the search for remote disk images prior to the Haiku menu.<br>
<div class="alert alert-warning">The completeness of remote disk booting may vary based on architecture. The architectures below are known working at the time of this guide's writing, your mileage may vary.</div>
<ul> <!-- start booting systems section -->
<li>
<h5>x86</h5>The x86 version of the Haiku boot loader can be booted via a PXE server.
<ul>
<li>
<h5>PXE Boot</h5>
Generate the x86 PXE bootloader via...
<pre class="terminal">TARGET_BOOT_PLATFORM=pxe_ia32 jam -q pxehaiku-loader haiku-netboot-archive</pre>

This will generate a boot image in tar.gz format and a pxe loader for it:
<pre>haiku-netboot.tgz
objects/haiku/x86_gcc2/release/system/boot/pxehaiku-loader</pre>

The image generated can be booted via a DHCP by placing both files generated above
on a TFTP server and pointing to the loader via the DHCP 'next-server/filename' options.
</li>
</ul>
</li>

<li>
<h5>PowerPC</h5>The PowerPC version of Haiku can be started headless via TFTP or CD.
<ul>
<li>
<h5>TFTP boot</h5>
Copy the boot_loader_openfirmware boot binary to your build system's TFTP share.<br><br>
At the OpenFirmware prompt, execute the following OpenFirmware command replacing TFTP_SERVER_IP with the IP of the tftp server. Optionally you can specify the test systems client address via MY_IP_ADDRESS.
<pre class="terminal">boot enet:TFTP_SERVER_IP,boot_loader_openfirmware&lt;,MY_IP_ADDRESS&gt;</pre>

</li>
</ul>

</li>
</ul> <!-- end booting systems section -->